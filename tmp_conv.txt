from sqlalchemy.orm import Session
from typing import List, Optional, Dict, Any
from ..models.models import Conversation, Message, User
from ..models.schemas import ConversationCreate, MessageCreate, ChatRequest, ChatResponse, MemoryCreate, RAGSearchRequest
from ..services.llm_service import get_llm_service
from ..services.memory_service import MemoryService
from ..services.rag_service import RAGService, get_rag_service
from datetime import datetime
import uuid
import json

class ConversationService:
    def __init__(self, db: Session):
        self.db = db
        self.memory_service = MemoryService(db)
        self.rag_service = get_rag_service(db)

    def create_conversation(self, conversation_data: ConversationCreate, user_id: Optional[int] = None) -> Conversation:
        """
        åˆ›å»ºæ–°å¯¹è¯?
        """
        conversation = Conversation(
            title=conversation_data.title,
            user_id=user_id
        )
        self.db.add(conversation)
        self.db.commit()
        self.db.refresh(conversation)
        return conversation

    def get_conversation(self, conversation_id: int) -> Optional[Conversation]:
        """
        è·å–å¯¹è¯è¯¦æƒ…
        """
        return self.db.query(Conversation).filter(Conversation.id == conversation_id).first()

    def get_user_conversations(self, user_id: Optional[int] = None, limit: int = 50) -> List[Conversation]:
        """
        è·å–ç”¨æˆ·çš„å¯¹è¯åˆ—è¡?
        """
        query = self.db.query(Conversation)
        if user_id:
            query = query.filter(Conversation.user_id == user_id)
        return query.order_by(Conversation.updated_at.desc()).limit(limit).all()

    def add_message(self, message_data: MessageCreate) -> Message:
        """
        æ·»åŠ æ¶ˆæ¯åˆ°å¯¹è¯?
        """
        message = Message(
            conversation_id=message_data.conversation_id,
            role=message_data.role,
            content=message_data.content,
            message_type=message_data.message_type,
            media_url=message_data.media_url
        )
        self.db.add(message)
        self.db.commit()
        self.db.refresh(message)

        # æ›´æ–°å¯¹è¯çš„æ›´æ–°æ—¶é—?
        conversation = self.get_conversation(message_data.conversation_id)
        if conversation:
            conversation.updated_at = datetime.utcnow()
            self.db.commit()

        return message

    def get_conversation_messages(self, conversation_id: int) -> List[Message]:
        """
        è·å–å¯¹è¯çš„æ‰€æœ‰æ¶ˆæ?
        """
        return self.db.query(Message).filter(Message.conversation_id == conversation_id).order_by(Message.created_at.asc()).all()

    async def process_chat_message(self, chat_request: ChatRequest, user_id: Optional[int] = None) -> ChatResponse:
        """
        å¤„ç†èŠå¤©æ¶ˆæ¯å¹¶è¿”å›AIå›å¤ï¼Œé›†æˆè®°å¿†åŠŸèƒ?
        """
        # åˆ›å»ºæˆ–è·å–å¯¹è¯?
        if not chat_request.conversation_id:
            conversation = self.create_conversation(
                ConversationCreate(title=chat_request.message[:50] + "..."),
                user_id
            )
            chat_request.conversation_id = conversation.id
        else:
            conversation = self.get_conversation(chat_request.conversation_id)
            if not conversation:
                raise ValueError("Conversation not found")

        # æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
        user_message = self.add_message(MessageCreate(
            conversation_id=chat_request.conversation_id,
            role="user",
            content=chat_request.message,
            message_type=chat_request.message_type,
            media_url=chat_request.media_url
        ))

        # æ„å»ºæ¶ˆæ¯å†å²
        messages = self.get_conversation_messages(chat_request.conversation_id)
        message_history = [{"role": msg.role, "content": msg.content} for msg in messages]

        # è·å–è®°å¿†ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœå¯ç”¨è®°å¿†åŠŸèƒ½ï¼?
        session_id = f"session_{chat_request.conversation_id}"
        memory_context = {}
        if chat_request.use_memory:
            memory_context = await self.memory_service.get_relevant_context(
                chat_request.message, session_id, user_id, chat_request.conversation_id
            )
        else:
            # å³ä½¿ä¸ä½¿ç”¨è®°å¿†ï¼Œä¹Ÿè¦åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„å·¥ä½œè®°å¿†ï¼Œç”¨äºä¿æŒå¯¹è¯ä¸Šä¸‹æ–?
            memory_context = {
                "relevant_memories": [],
                "working_memory": {},
                "session_context": {
                    "session_id": session_id,
                    "timestamp": datetime.utcnow().isoformat()
                }
            }

          # è·å–RAGä¸Šä¸‹æ–‡ï¼ˆè‡ªåŠ¨æ£€æµ‹è´­ç‰©ç›¸å…³æŸ¥è¯¢ï¼‰
          rag_context = []
          if self._is_shopping_related_query(chat_request.message):
              try:
                  # ä¸é™å®?knowledge_base_idsï¼Œå…è®¸ä»æ‰€æœ‰å·²å»ºç«‹çš„çŸ¥è¯†åº“ä¸­æ£€ç´¢ï¼Œ
                  # åŒ…æ‹¬æ‰‹æœºå¯¼è´­çŸ¥è¯†åº“ç­‰ä¸“ä¸šçŸ¥è¯†åº“ã€?                  rag_search = RAGSearchRequest(
                      query=chat_request.message,
                      knowledge_base_ids=[],
                      limit=5,
                      threshold=0.6
                  )
                  rag_results = await self.rag_service.search_knowledge_base(rag_search)
                  if rag_results:
                      rag_context = rag_results
              except Exception as e:
                  print(f"RAG search error: {e}")

        # æ„å»ºåŒ…å«è®°å¿†å’ŒRAGçš„å¢å¼ºæ¶ˆæ¯å†å?
        enhanced_message_history = self._build_enhanced_message_history(message_history, memory_context, rag_context)

        # å¤„ç†å¤šæ¨¡æ€æ¶ˆæ?
        llm_service = get_llm_service()
        if llm_service is None:
            raise Exception("LLMæœåŠ¡æœªåˆå§‹åŒ–ï¼Œè¯·æ£€æŸ¥APIå¯†é’¥é…ç½®")
        
        if chat_request.message_type == "image" and chat_request.media_url:
            # å›¾åƒåˆ†æ
            analysis_result = await llm_service.analyze_image(
                chat_request.media_url,
